---
hip: 551
title: Batch transactions
author: Piotr Swierzy <piotr.swierzy@arianelabs.com>
working-group: Nick Poorman <@nickpoorman>, Michael Garber <@mgarbs>, Ashe Oro <@Ashe-Oro>, Bug Bytes <@bugbytes>, Patrick Woo-Sam <@pwoosam>, Michael Heinrichs <@netopyr>, Ty Smith <@ty-swirldslabs>
type: Standards Track
category: Service
needs-council-approval: Yes
status: Accepted
last-call-date-time: 2023-10-26T07:00:00Z
created: 2022-07-25
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/531
updated: 2024-12-19
---

## Abstract

This HIP defines a mechanism to execute batch transactions such that a series of transactions (HAPI calls) depending on each other can be rolled into one transaction that passes the ACID test (atomicity, consistency, isolation, and durability).

## Motivation

The existing implementation of transactions in the Hedera network does not allow multiple different HAPI transactions to be called in one single network transaction that would have all the ACID properties. This makes it impossible to create more complicated flows without using smart contracts (which do not support all the HAPI transactions at this point) and listening to the mirror node to check the status of the previous transaction.

This approach will abstract away the need for smart contracts in certain cases, simplifying development and offering better user experiences by ensuring that all or none of the grouped transactions are applied. This feature will provide enhanced security for transactions that require an atomic execution flow.

## Rationale

Introducing a feature that allows grouped HAPI transactions to execute atomically within a single network transaction will use-cases for native services, thereby simplifying development workflows. It will ensure that grouped transactions are either fully applied or fully rolled back, enhancing both security and the user experience by streamlining development and preventing partial executions or inconsistencies in critical transaction flows. This will guarantee a malicious user cannot inject a new transaction in between the execution of the original transactions (cannot perform a sandwich attack).

## User Stories

### Use Case 1: Account-bound NFTs

As a Hedera Token Service user, I want to be able to unfreeze an account, send an NFT, and freeze the account again in one ACID transaction to create an account-bound NFT collection, without using the smart contract service. This could be used to issue nontransferable NFTs as digital references or achievements.

### Use Case 2: Account-bound FTs

I want to unfreeze an account, send fungible tokens (FT), and freeze it again in one ACID transaction to create account-bound FT collections, such as game points or reputation points.

### Use Case 3: Complex Token Flows

I want to batch multiple token operations, such as wiping, minting, and transferring tokens, into one ACID transaction to avoid handling partially successful transactions.

### Use Case 4: Cross-Service Batch

I want to wipe a token, mint a token, transfer a token, and submit a topic message in one ACID transaction to enable complex flows across different Hedera services without smart contracts.

### Use Case 5: Gift Token with Mint

I want to mint and transfer tokens in one ACID transaction when gifting tokens to a user, simplifying the process and avoiding the need for separate transactions.

### Use Case 6: Revoke KYC and Wipe Tokens

I want to batch KYC granting, token wiping, and KYC revoking into one ACID transaction to avoid situations where tokens are transferred from a revoked KYC account before I can wipe them.

### Use Case 7: Batch Key Approval Workflow

As a Hedera network user managing multiple transactions with sensitive permissions, I want to enforce that a specific trusted entity (batch key holder) approves an entire batch transaction before it is submitted. This allows for a streamlined, secure approval process for high-stakes transactions, ensuring only authorized batches are executed in scenarios such as account fund transfers, asset movements, or sensitive permission updates.

## Specification

### Transaction Integrity

1. Each inner transaction within a batch should be treated as a self-contained transaction.
2. If an inner transaction fails, preceding transactions that succeeded will still incur fees, even though their effects are not committed.
3. Inner transactions are individually signed regular transactions indicating that once a person signs an inner transaction, they have agreed to its outcome.

### Batch Signatures

- Batch transactions require unique signatures for the batch itself. Inner transactions cannot be rearranged post-signature.
- The primary audience for batch transactions are developers and dApps but rather for developers and dApps. When someone signs a transaction, they individually agree to the outcome, thus the individual transaction signers within the batch need not sign the batch itself. The ability for developers and dApps to execute atomic transactions across different services on Hedera enable more flexibility and certainty when executing complex use cases.

### Handling Inner Transactions

Inner transactions, by design:

1. Are signed individually.
2. Each pays for itself (node + network + service fees).
3. Have their own payer.
4. Are deduplicated on an individual basis.
5. Are authorized solely by their keys; batch keys are not used for authorization.
6. If one of the inner transactions has a child transaction, the parent transaction is in the batch, and the batch isnâ€™t successful, then the child transaction should also be reverted.

The batch:

1. Has its own payer and signatures.
2. Considers inner transactions as part of its signed bytes.
3. The standard max transaction size must be respected.
4. Makes the batch payer cover node+network fees for handling the batch, excluding inner transaction fees.
5. Has deduplication based on its unique transaction ID.
6. The submitter does not need to be authorized to carry out all the inner batch transactions. As with every transaction in Hedera, where the submitter can be any account as long as the transaction is properly signed.

### BatchKey Introduction

- To prevent malicious actors from tampering with a batch (e.g., removing, reordering, or adding transactions), a  `batchKey` will be introduced in the `TransactionBody`.
- The `batchKey` signals the trusted signer who can finalize the batch. This key ensures that batch transactions can only be submitted as a whole and prevents individual transactions from being executed outside the batch context.

### New Protobuf Changes

A batchKey will be added to the TransactionBody. In addition, the TransactionBody will include a new AtomicBatchTransactionBody. 

```protobuf
message TransactionBody {
    // Existing properties omitted.

    /**
    * The <b>entire public key</b> of the trusted batch assembler.
    *
    * Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
    */
    Key batchKey = 63;

    oneof data {
      // Existing values omitted.

      AtomicBatchTransactionBody atomicBatchTransactionBody = 64;
    }
}

```

The AtomicBatchTransactionBody will contain the transaction(s) that make up the batch.

```protobuf
message AtomicBatchTransactionBody {
    repeated Transaction transactions = 1;
}

```

The top-level `AtomicBatchTransactionBody` must be signed by the `batchKey` specified in the included transactions. There may only be one `batchKey` set for all the transactions in the batch. i.e. Inner transaction X cannot have a different `batchKey` than inner transaction Y.

We must return what transaction failed in the batch when the batch fails.

```protobuf
message TransactionReceipt {
    // Existing properties omitted.
    
    repeated ResponseCodeEnum batchTransactionStatus = 16;
}
```

### Security Enhancements

1. The batch transaction system prevents malicious actors from tampering with transactions by requiring them to be processed as a single unit.
2. A `batchKey` ensures only the trusted assembler (e.g., Alice) can create a valid batch. Nodes attempting to disassemble the batch or alter it will invalidate the transaction.

### Batch Transaction Timeout

All inner transactions must execute within the standard `transactionValidStart` and `transactionValidDuration` (typically 3 minutes) to ensure they remain valid during batch processing.

## Backward Compatibility

This proposal is backward compatible with existing Hedera transaction models, as it introduces a new message type for batch transactions without changing current transaction structures.

## Security Implications

Security is reinforced by ensuring that inner transactions cannot be executed outside the batch and by preventing malicious nodes from modifying batch transactions. The use of a `batchKey` ensures that only the trusted entity can assemble and submit the batch.

## Rejected Ideas

Conditional branching within batch transactions was rejected as it would introduce unnecessary complexity without significant value for the proposed use cases.

## Open Issues

The need to return details of failed transactions when a batch fails remains an open issue, as partial failures within the batch might require specific information to be returned to the user for debugging and recovery.