---
hip: 668
title: Mirror Node GraphQL API
author: Steven Sheehy <steven.sheehy@swirldslabs.com>
working-group: Daniel Costa <daniel@arkhia.io>
type: Standards Track
category: Mirror
needs-council-approval: Yes
status: Draft
created: 2022-11-29
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/669
updated: 2023-03-28
---

## Abstract

Defines a new GraphQL API for the Hedera Mirror Node.

## Motivation

The current mirror node REST API provides a functional API that returns most of the data users need. However, due to the
nature of REST APIs, it suffers from problems inherit in REST itself including both under-fetching and over-fetching.

Under-fetching can occur when the user does one query to fetch a list of items, then for each item in the list does
another query to get nested data. For example, if you use the REST API to query for a list of accounts and then get each
account's list of NFTs. REST APIs don't allow the user to define the nested or related data to return everything in one
response and avoid multiple round trips to the server. Similarly, REST APIs don't support standard ways of doing nested
pagination that would allow for such query patterns. If the user is going to do this `N+1` call regardless we might
as well do it more efficiently on the server side.

Over-fetching can occur when all fields are returned in the REST response. The user should be able to
select which fields they care about and the API should return only those. Some REST APIs allow users to supply a
list of fields to return which works fine for top-level fields but breaks down when attempted for nested fields or
lists.

GraphQL is an API query language developed by Facebook (Meta) and now widely accepted as a popular alternative to REST.
It can help alleviate some of the above problems and the development of such an API has been requested from internal and
external members of the Hedera community.

## Rationale

The main goal of the mirror node GraphQL API is to expose data customers need in the format they require. It
should take the current REST API as inspiration and expose a similar set of data but in a format more suitable for
GraphQL. Data should be nested and allow for pagination at different levels. Strongly typed objects should be preferred
over complex string representations of multi-field objects similar to the protobuf-based HAPI. For example, instead of
the transaction ID being a string as in the REST API, it could be a GraphQL type `TransactionId` with
`nonce`, `payerAccountId`, `scheduled`, and `validStart` fields where even those could be complex types.

An existing GraphQL API for the Hedera network was created by community members under the name
[Hgraph.io](https://www.hgraph.io/). This API uses the open source Hedera mirror node code base as its source of
information. We decided not to base the GraphQL schema in this HIP off of Hgraph's schema for a number of reasons. For
one, Hgraph is not open source, so we could not leverage its codebase as a starting point. Secondly, the GraphQL schema
it defines is almost a one-to-one mapping of the database schema without much, if any, nesting of data. This negates one
of the main benefits of GraphQL by not taking advantage of nested pagination and allowing the client to retrieve larger
graphs of data. The open source mirror node does not provide any guarantees of database schema compatibility between
releases so this schema will become harder to maintain over time without the use of a view model abstraction layer.

[The Graph](https://thegraph.com/) provides an indexing protocol for networks and allows anyone to publish sub-graphs
for their subset of data. Hedera could write an indexer to integrate with The Graph, thus exposing Hedera data for use
in sub-graphs. While The Graph does use GraphQL for its subgraph, it differs from the intent of the API in this HIP. The
Graph can only index individual smart contracts and their storage, allowing for rich sub-graphs that are specific to
that specific contract. It cannot be used to expose the numerous non-contract related entities in Hedera like accounts,
tokens, etc. Thus, it cannot be used as a general purpose mirror node API.

## User stories

#### As a dApp developer, I want to request only the exact data that I need.

The current mirror node REST API does not allow fetching a subset of fields. With GraphQL, this capability is
built-in to the protocol.

#### As a dApp developer, I want to avoid multiple requests to the API to get my data quicker.

The current mirror node REST API does not allow paging nested data and requires separately querying many
sub-resources. GraphQL has built-in support for nested pagination
via [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm).

#### As a JSON-RPC relay operator, I want to reduce maintenance costs and improve latency.

The open source JSON-RPC relay could take advantage of the new GraphQL API by replacing many REST API calls with one
GraphQL call.

#### As an explorer, I want to reduce page load times.

The open source Hedera Mirror Node Explorer could take advantage of the new GraphQL API by replacing many REST API
calls with one GraphQL call.

## Specification

The new GraphQL API will be written as a new module in the open source Hedera Mirror Node repository. It will be Java
based to allow for code reuse with its other modules. It will interact directly with the SQL database like the other
modules. Creating it as a separate module will allow it to be a microservice that can be scaled separately from other
components to auto-scale based upon load. The API will be defined in a contract-first manner using the GraphQL schema
files defined in the following sections. The view model will be auto-generated from the schema using a Gradle plugin.

The API should abide by the `Node` interface and
[global object identification](https://graphql.org/learn/global-object-identification/) best practices. The `Node`
interface provides a common interface across all top-level types and has a single `id: ID!` field defined. The
`id` is an opaque string specific to the GraphQL API that is returned via the API and can be used in subsequent API
calls. Finally, the API will provide a root `node(id)` query to provide the ability to re-fetch objects by their global
identifier. These all combine to allow for consistent object access, enabling clients to cache objects and re-fetch them
in a standardized way. Similarly, it allows servers to implement a standardized caching mechanism across all domain
objects.

Pagination will be done using the GraphQL Cursor Connections Specification de facto standard defined by Meta.
This specification wraps lists in a `Connection` object that contains a list of edges and a common `PageInfo`.
Pagination takes advantage of the opaque `id` defined by the `Node` interface to return an opaque cursor that clients
can pass to the server on subsequent calls to allow for an efficient cursor-based database pagination. The
`PageInfo` returns the start or end cursor associated with the last page that can be passed via the connection as either
an `after` or `before` arguments to perform either ascending or descending order pagination, respectively. While
we feel the edge wrapper is a bit unnecessary, following the specification as is provides for a good out of the box
experience with most GraphQL clients.

### Queries

The current REST API has two broad top-level query patterns: list all entities/transactions or get a specific
entity/transaction. Based upon metrics, the latter scenario is a lot more common since dApps
will generally want to look up their specific account, topic, transaction, etc. Alternatively, they want to list all
data specific to their entity like all transactions involving a certain account. Listing across accounts or other top
level resources makes more sense for narrower use cases like explorers or analytics.

With upcoming work to shard the database by its Hedera entity, queries that involve many entities will be less
efficient to execute since they will involve fetching data from all database shards spread across many physical database
instances. For these reasons, we will avoid creating list APIs that paginate across entities and focus our efforts on
paginating within a specific entity. In the future, we could entertain adding such a feature, but it would be most
likely constrained to the last `X` or top `N` type queries and not allow pagination to allow for caching.

```graphql
"The query root of the Hedera GraphQL API"
type Query {
  account(id: AccountIdInput!): Account
  block(id: BlockIdInput!): Block
  contract(id: ContractIdInput!): Contract
  file(id: FileIdInput!): File
  network: Network!
  node(id: ID! @Pattern(regexp: "^[a-zA-Z0-9+/=]+$")): Node
  schedule(id: ScheduleIdInput!): Schedule
  token(id: TokenIdInput!): Token
  topic(id: TopicIdInput!): Topic
  transaction(id: TransactionInput!): [Transaction!]!
}

```

### Directives

Below are the custom directives that aid in validating input in a declarative manner. Providing validation directives
makes it explicit in the schema the input requirements instead of requiring an out-of-band communication of validation
criteria.

```graphql
"Validation directive that ensures the argument or input is a certain minimum value."
directive @Min(value: Int! = 0, message: String = "graphql.validation.Min.message")
on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

"Validation directive that ensures the argument or input value matches the given regular expression."
directive @Pattern(regexp: String! =".*", message: String = "graphql.validation.Pattern.message")
on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

```

### Scalars

In addition to the built-in scalars, this API defines a few custom scalars.

```graphql
"An ISO 8601 compatible duration with support for nanoseconds granularity in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S."
scalar Duration

"A 64-bit signed numeric type."
scalar Long

"A map-like object with dynamic key/value pairs."
scalar Object

"""
An ISO 8601 compatible timestamp with nanoseconds granularity. All timestamps are consensus timestamps assigned by
Hedera nodes.
"""
scalar Timestamp
```

### Common

Below are the enums, inputs, interfaces, and types that are common to more than one of the queries. One thing to note
is that every entity on the Hedera network like accounts, contracts, files, etc. has a shared incrementing `EntityId`
identifier and has a common set of fields defined by the `Entity` interface.

```graphql
"A specialization of an Entity appropriate for entities that have a Hbar balance."
interface Accountable implements Entity & Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The balance of the accountable entity. Defaults to tinybars."
  balance(unit: HbarUnit = TINYBAR): Long

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Whether the entity declines receiving a staking reward."
  declineReward: Boolean!

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  "The 20 byte EVM address associated with this entity."
  evmAddress(encoding: BinaryEncoding = HEX): String!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The memo associated with the entity."
  memo: String!

  "The accountable entity to receive the remaining balance from the deleted entity."
  obtainer: Accountable

  """
  The pending reward the account will receive in the next reward payout. Note the value is updated at the end of each
  staking period and there may be delay to reflect the changes in the past staking period. Defaults to tinybars.
  """
  pendingReward(unit: HbarUnit = TINYBAR): Long

  "The entity to which this account is staked. Mutually exclusive with stakedNode."
  stakedEntity: Accountable

  "The node to which this account is staked. Mutually exclusive with stakedEntity."
  stakedNode: NetworkNode

  """
  The staking period during which either the staking settings for this account changed (such as starting staking or
  changing stakedNode) or the most recent reward was earned, whichever is later. If this account is not currently
  staked to a node, then the value is null.
  """
  stakePeriodStart: Timestamp

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!
}

"The encoding used to convert the raw bytes to String."
enum BinaryEncoding {
  "Base 64 encoding."
  BASE64

  "Base 16 hexadecimal encoding with a '0x' prefix and using lowercase letters and numbers."
  HEX
}

"""
The base type for an entity on the Hedera network. Each entity is assigned an incrementing identifier that is shared
across all entity types and associated with a particular shard and realm.
"""
interface Entity implements Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Whether the entity still exists on the ledger."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The memo associated with the entity."
  memo: String!

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!
}

"An incrementing identifier that is shared across all entity types and associated with a particular shard and realm."
type EntityId {
  "The unique incrementing identifier associated with this entity."
  num: Long!

  "The realm number. Currently always zero."
  realm: Long!

  "The shard number to allow for horizontal scaling of networks. Currently always zero."
  shard: Long!
}

"The unique identifier to find an entity on the Hedera network."
input EntityIdInput {
  "The unique incrementing identifier associated with this entity."
  num: Long! @Min(value: 0)

  "The realm number. Defaults to zero."
  realm: Long! = 0 @Min(value: 0)

  "The shard number to allow for horizontal scaling of networks. Defaults to zero."
  shard: Long! = 0 @Min(value: 0)
}

"A rational number, used to provide an accurate number without any rounding issues and to provide consistency with HAPI."
type Fraction {
  "The rational's denominator. Will be a value of one when the numerator should be treated as a whole number."
  denominator: Long!

  "The rational's numerator"
  numerator: Long!
}

"""
The unit to format the hbar amount. Tinybars is the smallest and most exact unit. Anything beyond tinybars will
potentially result in a loss of information.
"""
enum HbarUnit {
  "1 Gℏ = 1,000,000,000 ℏ"
  GIGABAR

  "1 Mℏ = 1,000,000 ℏ"
  MEGABAR

  "1Kℏ = 1,000 ℏ"
  KILOBAR

  "1 ℏ = 1 ℏ"
  HBAR

  "1,000 mℏ = 1 ℏ"
  MILIBAR

  "1,000,000 μℏ = 1 ℏ"
  MICROBAR

  "100,000,000 tℏ = 1 ℏ"
  TINYBAR
}

"""
A GraphQL object with a globally unique ID. A GraphQL concept and standard that's not to be confused with a consensus
node or mirror node.
"""
interface Node {
  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!
}

"Contains the pagination metadata for a particular connection."
type PageInfo {
  "When paginating forwards, the cursor to continue. Empty string indicates no more results."
  endCursor: String!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating backwards, the cursor to continue. Empty string indicates no more results."
  startCursor: String!
}

"A release identifier that follows semantic versioning (https://semver.org/)."
type SemanticVersion {
  "The major version indicates incompatible API changes."
  major: Int!

  "The minor version indicates new, backwards-compatible functionality."
  minor: Int!

  "The patch version indicates backwards compatible bug fixes."
  patch: Int!
}

"""
A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp. Usually indicates the
consensus timestamp range in which the data was in effect on the network.
"""
type TimestampRange {
  "A timestamp that marks the inclusive beginning of the range."
  from: Timestamp!

  "A timestamp that marks the exclusive end of the range."
  to: Timestamp
}

"The type of transaction submitted to the Hedera network."
enum TransactionType {
  CONSENSUSCREATETOPIC
  CONSENSUSDELETETOPIC
  CONSENSUSSUBMITMESSAGE
  CONSENSUSUPDATETOPIC
  CONTRACTCALL
  CONTRACTCREATEINSTANCE
  CONTRACTDELETEINSTANCE
  CONTRACTUPDATEINSTANCE
  CRYPTOADDLIVEHASH
  CRYPTOAPPROVEALLOWANCE
  CRYPTOCREATEACCOUNT
  CRYPTODELETE
  CRYPTODELETEALLOWANCE
  CRYPTODELETELIVEHASH
  CRYPTOTRANSFER
  CRYPTOUPDATEACCOUNT
  ETHEREUMTRANSACTION
  FILEAPPEND
  FILECREATE
  FILEDELETE
  FILEUPDATE
  FREEZE
  NODESTAKEUPDATE
  PRNG
  SCHEDULECREATE
  SCHEDULEDELETE
  SCHEDULESIGN
  SYSTEMDELETE
  SYSTEMUNDELETE
  TOKENASSOCIATE
  TOKENBURN
  TOKENCREATION
  TOKENDELETION
  TOKENDISSOCIATE
  TOKENFEESCHEDULEUPDATE
  TOKENFREEZE
  TOKENGRANTKYC
  TOKENMINT
  TOKENPAUSE
  TOKENREVOKEKYC
  TOKENUNFREEZE
  TOKENUNPAUSE
  TOKENUPDATE
  TOKENWIPE
  UNCHECKEDSUBMIT
  UNKNOWN
}
```

### Account

The account is the main entrypoint into the Hedera network. The `Account` type retrieves a specific account and can
show various data related to the account like allowances, NFTs, tokens, transactions, etc.

```graphql
"Represents a Hedera account holder on the network."
type Account implements Accountable & Entity & Node {
  "The unique alias associated with this account."
  alias(encoding: BinaryEncoding = BASE64): String

  "The allowances granting the right to transfer a pre-determined amount of the owner's hbars or tokens."
  allowances: Allowances!

  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The balance of the accountable entity. Defaults to tinybars."
  balance(unit: HbarUnit = TINYBAR): Long

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Whether the entity declines receiving a staking reward."
  declineReward: Boolean!

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  "The 20 byte EVM address associated with this entity."
  evmAddress(encoding: BinaryEncoding = HEX): String!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The maximum number of tokens that this account can be implicitly associated with."
  maxAutomaticTokenAssociations: Int

  "The memo associated with the entity."
  memo: String!

  "Lists the non-fungible tokens associated with this account."
  nfts(after: String, before: String, first: Int, last: Int): NftConnection!

  "The ethereum transaction nonce associated with this account."
  nonce: Long

  "The accountable entity to receive the remaining balance from the deleted entity."
  obtainer: Accountable

  """
  The pending reward the account will receive in the next reward payout. Note the value is updated at the end of each
  staking period and there may be delay to reflect the changes in the past staking period. Defaults to tinybars.
  """
  pendingReward(unit: HbarUnit = TINYBAR): Long

  "Whether the admin key must sign any transaction depositing into this account (in addition to all withdrawals)."
  receiverSigRequired: Boolean

  "The entity to which this account is staked. Mutually exclusive with stakedNode."
  stakedEntity: Accountable

  "The node to which this account is staked. Mutually exclusive with stakedEntity."
  stakedNode: NetworkNode

  """
  The staking period during which either the staking settings for this account changed (such as starting staking or
  changing stakedNode) or the most recent reward was earned, whichever is later. If this account is not currently
  staked to a node, then the value is null.
  """
  stakePeriodStart: Timestamp

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!

  "Lists the token relationships associated with this account."
  tokens(after: String, before: String, first: Int, last: Int): TokenAssociationConnection!

  "Lists the transactions associated with this account."
  transactions(after: String, before: String, first: Int, last: Int): TransactionConnection!
}

"""
The unique identifier to find a specific account. Only one of the given fields can be present at a time otherwise an
error will occur.
"""
input AccountIdInput {
  "A RFC 4648 Base32 encoded string with the trailing '=' characters removed that represents an account alias."
  alias: String @Pattern(regexp: "^[A-Z2-7]+$")

  "The unique shard, realm, and number associated with a Hedera account."
  entityId: EntityIdInput

  "A hex-encoded string that represents a 20-byte EVM address."
  evmAddress: String @Pattern(regexp: "^(0x)?[a-fA-F0-9]{40}$")
}

"An allowance grants a spender the right to transfer a subset of the owner's assets."
interface Allowance implements Node {
  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The spender for this allowance."
  spender: Accountable!

  "The effective time range for this allowance."
  timestamp: TimestampRange!
}

"The allowances granting the right to transfer a pre-determined amount of the owner's hbars or tokens."
type Allowances {
  "List the allowances granting approved spenders the right to transfer hbars from this account."
  crypto(after: String, before: String, first: Int, last: Int): CryptoAllowanceConnection!

  "List the allowances granting approved spenders the right to transfer NFTs from this account."
  nft(after: String, before: String, first: Int, last: Int): NftAllowanceConnection!

  "List the allowances granting approved spenders the right to transfer tokens from this account."
  token(after: String, before: String, first: Int, last: Int): TokenAllowanceConnection!
}

"An approved allowance of hbar transfers for a spender."
type CryptoAllowance implements Allowance & Node {
  "The granted amount of the spender's allowance."
  amount(unit: HbarUnit = TINYBAR): Long!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The spender for this allowance."
  spender: Accountable!

  "The effective time range for this allowance."
  timestamp: TimestampRange!
}

"The connection type for CryptoAllowance."
type CryptoAllowanceConnection {
  "A list of edges."
  edges: [CryptoAllowanceEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CryptoAllowanceEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: CryptoAllowance!
}

"An approved allowance of non-fungible token transfers for a spender."
type NftAllowance implements Allowance & Node {
  "Whether the spender has access to all of the owner's NFTs (currently owned and any in the future)."
  approvedForAll: Boolean!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The spender for this allowance."
  spender: Accountable!

  "The effective time range for this allowance."
  timestamp: TimestampRange!

  "The token that the allowance pertains to."
  token: Token!
}

"The connection type for NftAllowance."
type NftAllowanceConnection {
  "A list of edges."
  edges: [NftAllowanceEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NftAllowanceEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: NftAllowance!
}

"An approved allowance of fungible token transfers for a spender."
type TokenAllowance implements Allowance & Node {
  "The granted amount of the spender's allowance."
  amount: Long!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The spender for this allowance."
  spender: Accountable!

  "The effective time range for this allowance."
  timestamp: TimestampRange!

  "The token that the allowance pertains to."
  token: Token!
}

"The connection type for TokenAllowance."
type TokenAllowanceConnection {
  "A list of edges."
  edges: [TokenAllowanceEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TokenAllowanceEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: TokenAllowance!
}

"Defines the relationship between an account and its associated token."
type TokenAssociation implements Node {
  "Specifies if the relationship is implicitly or explicitly associated."
  automatic: Boolean!

  "For fungible tokens, the balance that the account holds."
  balance: Long!

  "The consensus timestamp at which this account was associated to this token."
  createdTimestamp: Timestamp!

  "The entity associated to the token."
  entity: Accountable!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The freeze status of the account. Returns NOT_APPLICABLE if this token does not have a freeze key."
  freezeStatus: FreezeStatus!

  "The KYC status of the account. Returns NOT_APPLICABLE if this token does not have a KYC key."
  kycStatus: KycStatus!

  "The consensus timestamp range for which this relationship is effective."
  timestamp: TimestampRange!

  "The token this account is associated with."
  token: Token!
}

"The connection type for TokenAssociation."
type TokenAssociationConnection {
  "A list of edges."
  edges: [TokenAssociationEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TokenAssociationEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: TokenAssociation!
}
```

### Block

A block, as defined in HIP-415, is a grouping of transactions ordered by their consensus timestamps. The API will allow
users to query for a specific block by different criteria.

```graphql
"""
A block is a grouping of transactions order by their consensus timestamp and linked by a cryptographic hash. See
HIP-415 for more details.
"""
type Block implements Node {
  "The number of transactions in the block."
  count: Long!

  "The amount of gas used by all EVM invoking transactions within the block."
  gasUsed: Long

  "Version of HAPI that was used to serialize the transactions within the block."
  hapiVersion: SemanticVersion

  "The end running hash of all the transactions in the block."
  hash(encoding: BinaryEncoding = HEX): String!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "A hex encoded 256-byte array that contains a bloom filter for all the contract logs associated with this block."
  logsBloom(encoding: BinaryEncoding = HEX): String

  "The file name of the record file used to serialize the block."
  name: String!

  "The block number associated with this period. Starts at zero and increments sequentially."
  number: Long!

  "The start running hash before any of the transactions in the block. Equal to the previous block's end running hash."
  previousHash(encoding: BinaryEncoding = HEX): String!

  "The size of the record file used to serialize the block before any decompression, if applicable."
  size: Int

  "The timestamp range associated with the first and last transactions in the block."
  timestamp: TimestampRange!

  "A list of transactions that occurred within the block."
  transactions(after: String, before: String, first: Int, last: Int): TransactionConnection!

  "The version of the record file that was used to serialize the block."
  version: Int!
}

"""
The unique identifier to get a specific block. Only one of the given fields can be present at a time otherwise an error
will occur.
"""
input BlockIdInput {
  "A 32-byte Ethereum hash or 48-byte Hedera hash in hexadecimal."
  hash: String @Pattern(regexp: "^(0x)?([A-Fa-f0-9]{64}|[A-Fa-f0-9]{96})$")

  "The positive number associated with this block."
  number: Long @Min(value: 0)

  "Used to identify a variable block without knowing its unique identifier."
  type: BlockType
}

"An identifier that represents a well-known or always changing block in the network."
enum BlockType {
  "The earliest block in the network. Usually equivalent to block number zero."
  EARLIEST

  "The most recent block seen by this node."
  LATEST
}
```

### Contract

Users can query their smart contract by its unique identifier and return associated info like the results or state.

```graphql
"The type of entity calling the contract."
enum CallerType {
  ACCOUNT
  CONTRACT
}

"The specific operation type of a call."
enum CallOperationType {
  CALL
  CALLCODE
  CREATE
  CREATE2
  DELEGATECALL
  STATICCALL
  UNKNOWN
}

"Represents a Hedera contract on the network."
type Contract implements Accountable & Entity & Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The balance of the accountable entity. Defaults to tinybars."
  balance(unit: HbarUnit = TINYBAR): Long

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Whether the entity declines receiving a staking reward."
  declineReward: Boolean!

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  "The 20 byte EVM address associated with this entity."
  evmAddress(encoding: BinaryEncoding = HEX): String!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "The Hedera file that stores the initcode used to create this contract. Mutually exclusive with the initcode field."
  file: File

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The initcode used to create this contract. Mutually exclusive with the file field."
  initcode(encoding: BinaryEncoding = HEX): String

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The memo associated with the entity."
  memo: String!

  "The accountable entity to receive the remaining balance from the deleted entity."
  obtainer: Accountable

  """
  The pending reward the account will receive in the next reward payout. Note the value is updated at the end of each
  staking period and there may be delay to reflect the changes in the past staking period. Defaults to tinybars.
  """
  pendingReward(unit: HbarUnit = TINYBAR): Long

  "Get a specific contract execution result."
  result(id: ContractResultId): ContractResult

  "List the contract execution results."
  results(after: String, before: String, first: Int, last: Int): ContractResultConnection!

  "The deployed bytecode that resulted from invoking the contract's constructor with its initcode."
  runtimeBytecode(encoding: BinaryEncoding = HEX): String

  "The entity to which this account is staked. Mutually exclusive with stakedNode."
  stakedEntity: Accountable

  "The node to which this account is staked. Mutually exclusive with stakedEntity."
  stakedNode: NetworkNode

  """
  The staking period during which either the staking settings for this account changed (such as starting staking or
  changing stakedNode) or the most recent reward was earned, whichever is later. If this account is not currently
  staked to a node, then the value is null.
  """
  stakePeriodStart: Timestamp

  "List the current key/value pairs associated with this contract storage."
  state(after: String, before: String, first: Int, last: Int): ContractStateConnection!

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!
}

"A fine grained action within a contract result. Sometimes called 'internal transactions'."
type ContractAction implements Node {
  "The nesting depth of this call. The original action is at depth zero."
  callDepth: Int!

  "The specific operation type of a call."
  callOperationType: CallOperationType!

  "The type of this action."
  callType: ContractActionType!

  "The entity calling the contract."
  caller: EntityId!

  "The type of entity calling the contract."
  callerType: CallerType!

  "The upper limit of gas this action can spend."
  gas: Long!

  "Bytes passed in as input data to this action."
  gasUsed: Long!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The position of the action within the ordered list of actions within the specific contract result."
  index: Int!

  "Bytes passed in as input data to this action."
  input(encoding: BinaryEncoding = HEX): String

  "Who the contract action is directed to."
  recipient: ContractActionRecipient!

  "The result data of the action."
  resultData(encoding: BinaryEncoding = HEX): String

  "The result data type of the contract action."
  resultDataType: ContractActionResultType!

  "The consensus timestamp at which this action occurred."
  timestamp: Timestamp!

  "The amount of currency that is associated with this action."
  value(unit: HbarUnit = TINYBAR): Long!
}

"The connection type for ContractAction."
type ContractActionConnection {
  "A list of edges."
  edges: [ContractActionEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContractActionEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: ContractAction!
}

"Who the contract action is directed to. Only one of the fields will be populated at a time."
type ContractActionRecipient {
  "If the recipient is an account. Only HBars will be transferred, no other side effects should be expected."
  accountId: EntityId

  """
  The bytes of the targeted address by the action. Only set on failed executions. If set, denotes that the address did
  not correspond to any account or contract at the time of finalization of this action.
  """
  address: String

  "If the recipient is a smart contract."
  contractId: EntityId
}

"The result data type of the contract action."
enum ContractActionResultType {
  "The transaction itself failed without an explicit `REVERT`."
  ERROR

  "If successful, the output bytes of the action."
  OUTPUT

  "The contract itself caused the transaction to fail via the `REVERT` operation."
  REVERT_REASON
}

"The type of contract action."
enum ContractActionType {
  "Most CALL, CALLCODE, DELEGATECALL, and STATICCALL, and first action of contract calls to deployed contracts."
  CALL

  "CREATE, CREATE2, and first action of ContractCreate."
  CREATE

  "Default non-value."
  NO_ACTION

  "Like Call, but to precompiled contracts (0x1 to 0x9 as of Berlin)."
  PRECOMPILE

  "Call, but to system contract like HTS or ERC20 facades over Token accounts."
  SYSTEM
}

"""
The unique identifier to find a specific contract. Only one of the given fields can be present at a time otherwise an
error will occur.
"""
input ContractIdInput {
  "The unique shard, realm, and number associated with a Hedera contract."
  entityId: EntityIdInput

  "A hex-encoded string that represents a 20-byte EVM address."
  evmAddress: String @Pattern(regexp: "^(0x)?[a-fA-F0-9]{40}$")
}

"The log information for an event returned by a smart contract function call."
type ContractLog implements Node {
  "The 20 byte Ethereum-compliant contract address that generated the log."
  address(encoding: BinaryEncoding = HEX): String!

  "The bloom filter for this log."
  bloom(encoding: BinaryEncoding = HEX): String!

  "The event data."
  data(encoding: BinaryEncoding = HEX): String!

  "The ID of the contract or other entity that emitted the event."
  entityId: EntityId!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The consensus timestamp this event was emitted."
  timestamp: Timestamp!

  "A list of up to four 256-bit topics associated with this log event."
  topics(encoding: BinaryEncoding = HEX): [String!]!
}

"The result of a contract's execution on the Hedera EVM."
type ContractResult implements Node {
  "Array of addresses that will be accessed."
  accessList(encoding: BinaryEncoding = HEX): String

  "A detailed list of operations that occurred during the contract execution."
  actions(after: String, before: String, first: Int, last: Int): ContractActionConnection!

  "The block this contract call occurred within."
  block: Block!

  "The bloom filter associated with this contract call."
  bloom(encoding: BinaryEncoding = HEX): String

  "The result returned by the function."
  callResult(encoding: BinaryEncoding = HEX): String

  "The transaction’s chain ID."
  chainId(encoding: BinaryEncoding = HEX): String

  "The parameters passed into the contract call."
  data(encoding: BinaryEncoding = HEX): String!

  "The message when an error occurs during smart contract execution."
  errorMessage: String

  "The Ethereum transaction type."
  ethereumType: Int!

  "The contract initcode of a failed contract create transaction."
  failedInitcode(encoding: BinaryEncoding = HEX): String

  "The 20-byte EVM address of the source account or contract."
  from(encoding: BinaryEncoding = HEX): String!

  "The maximum units of gas allowed for contract execution."
  gasLimit: Long!

  "Gas price used for each paid gas."
  gasPrice(encoding: BinaryEncoding = HEX): String

  "The units of gas used to execute the contract."
  gasUsed: Long

  "The 32 or 48 byte hash of the transaction, depending upon whether it's an EthereumTransaction or not."
  hash(encoding: BinaryEncoding = HEX): String!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The logs generated by the smart contract's events."
  logs: [ContractLog!]!

  "Maximum total fee in weibars the sender is willing to pay per gas."
  maxFeePerGas(encoding: BinaryEncoding = HEX): String

  "Maximum fee in weibars the sender is willing to pay per gas above the base fee."
  maxPriorityFeePerGas(encoding: BinaryEncoding = HEX): String

  "The transaction nonce for the sender."
  nonce: Long

  "The ECDSA signature."
  signature: ContractSignature

  "The changes to a smart contract's storage as a side effect of the function call."
  stateChanges: [ContractStateChange!]!

  "Whether the transaction was successful (0x1) or unsuccessful (0x0)."
  status: String!

  "The consensus timestamp at which this contract was executed."
  timestamp: Timestamp!

  "The target contract's 20-byte EVM address."
  to(encoding: BinaryEncoding = HEX): String!

  "The generic transaction information associated with this contract call."
  transaction: Transaction!

  "The number of hbars sent to a payable function."
  value(unit: HbarUnit = TINYBAR): Long

}

"The connection type for ContractResult."
type ContractResultConnection {
  "A list of edges."
  edges: [ContractResultEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContractResultEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: ContractResult!
}

"""
The unique identifier to find a specific result of a contract execution. Only one of the given fields can be present at
a time otherwise an error will occur.
"""
input ContractResultId {
  "The unique consensus timestamp at which this contract execution occurred."
  timestamp: Timestamp

  "The 32 byte transaction hash"
  transactionHash: String @Pattern(regexp: "^(0x)?[a-fA-F0-9]{64}$")

  "The client generated identifier associated with this transaction."
  transactionId: TransactionIdInput
}

"The ECDSA signature."
type ContractSignature {
  "The 32 byte ECDSA signature r."
  r(encoding: BinaryEncoding = HEX): String!

  "The 32 byte ECDSA signature s."
  s(encoding: BinaryEncoding = HEX): String!

  "ECDSA recovery ID."
  v(encoding: BinaryEncoding = HEX): String
}

"The current state of the contract's storage slot."
type ContractState implements Node {
  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The contract's storage slot."
  slot(encoding: BinaryEncoding = HEX): String!

  "The consensus timestamp at which this storage slot was last modified."
  timestamp: Timestamp!

  "The value associated with the storage slot."
  value(encoding: BinaryEncoding = HEX): String
}

"The connection type for ContractState."
type ContractStateConnection {
  "A list of edges."
  edges: [ContractStateEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContractStateEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: ContractState!
}

"The changes to a smart contract's storage as a side effect of the function call."
type ContractStateChange {
  "The contract to which the storage changes apply to."
  contractId: EntityId!

  "The storage slot changed."
  slot(encoding: BinaryEncoding = HEX): String!

  "The value read from the storage slot."
  valueRead(encoding: BinaryEncoding = HEX): String!

  "The new value written to the slot, if any."
  valueWritten(encoding: BinaryEncoding = HEX): String
}
```

### File

Users can query for a specific Hedera file and its associated data.

```graphql
"Represents a file on the Hedera network to allow arbitrarily large byte sequences on the ledger."
type File implements Entity & Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "The chunked file data. Since each piece of data can potentially be 6Kib, we limit the max results to at most 5."
  data(after: String, before: String, first: Int, last: Int): FileDataConnection!

  "Whether the entity still exists on the ledger."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network.
  """
  key: Object

  "The memo associated with the entity."
  memo: String!

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!
}

"The chunked file contents associated with a Hedera file."
type FileData implements Node {
  "The file's chunked binary data."
  bytes(encoding: BinaryEncoding = BASE64): String!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The timestamp this data was added to the network."
  timestamp: Timestamp!

  "The type of file transaction used to add this data. Allowed values are FILEAPPEND, FILECREATE, FILEUPDATE."
  transactionType: TransactionType!
}

"The connection for FileData."
type FileDataConnection {
  "A list of edges."
  edges: [FileDataEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type FileDataEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: FileData!
}

"The unique identifier to get a specific file."
input FileIdInput {
  "The unique shard, realm, and number associated with a Hedera file."
  entityId: EntityIdInput!
}
```

### Network

The network type allows groups queries for network-wide information like nodes, staking information, or released supply.

```graphql
"Contains information associated with the Hedera network as a whole."
type Network {
  "Get a node running on the network by its unique identifier."
  node(id: NetworkNodeIdInput!): NetworkNode

  "List the nodes running on the network."
  nodes(after: String, before: String, first: Int, last: Int): NetworkNodeConnection!

  "Get the network's current stake information."
  stake: NetworkStake!

  "Get the network's released supply. If no timestamp is supplied it will get the latest supply."
  supply(timestamp: Timestamp): NetworkSupply!
}

"A Hedera node running on the network that contributes to consensus."
type NetworkNode implements Node {
  "A description of the node."
  description: String

  "A list of service endpoints clients can use to connect to this node."
  endpoints: [NetworkNodeEndpoint!]!

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The maximum stake (rewarded or not rewarded) this node can have as consensus weight. Defaults to tinybars."
  maxStake(unit: HbarUnit = TINYBAR): Long

  """
  The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight. Defaults
  to tinybars.
  """
  minStake(unit: HbarUnit = TINYBAR): Long

  "The account to be paid for queries and transactions sent to this node."
  nodeAccount: Account!

  """
  A hash of the node's TLS certificate. Its value can be used to verify the node's certificate it presents during TLS
  negotiations.
  """
  nodeCertificateHash(encoding: BinaryEncoding = HEX): String

  "The numeric ID assigned by the network."
  nodeId: Long!

  "A X509 RSA public key used to verify stream file signature."
  publicKey(encoding: BinaryEncoding = BASE64): String

  "The total tinybars earned by this node per whole hbar in the last staking period."
  rewardRateStart: Long

  "The node consensus weight at the beginning of the staking period. Defaults to tinybars."
  stake(unit: HbarUnit = TINYBAR): Long

  """
  The sum (balance + stakedToMe) for all accounts staked to this node with declineReward=true at the beginning of the
  staking period. Defaults to tinybars.
  """
  stakeNotRewarded(unit: HbarUnit = TINYBAR): Long

  """
  The sum (balance + staked) for all accounts staked to the node that are not declining rewards at the beginning of
  the staking period. Defaults to tinybars.
  """
  stakeRewarded(unit: HbarUnit = TINYBAR): Long

  "The time range the staking period spans."
  stakingPeriod: TimestampRange
}

"The connection type for NetworkNode."
type NetworkNodeConnection {
  "A list of edges."
  edges: [NetworkNodeEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NetworkNodeEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: NetworkNode!
}

"Endpoint information for use by clients to connect to HAPI."
type NetworkNodeEndpoint {
  "The IPv4 address this node is using to serve its API."
  ipAddressV4: String!

  "The port this node is using to serve its API."
  port: Int!
}

"The unique identifier to find a specific node."
input NetworkNodeIdInput {
  "The consensus node's numeric ID assigned to it by the network."
  nodeId: Long!
}

"The network's current staking information."
type NetworkStake implements Node {
  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day."
  maxRewardRatePerHbar: Long!

  "A fraction between zero and one of the network and service fees paid to the node reward account 0.0.801."
  nodeRewardFeeFraction: Fraction!

  "The amount of time in a staking period."
  periodDuration: Duration!

  "The number of staking periods for which the reward is stored for each node."
  periodsStored: Long!

  "The fraction between zero and one of the network and service fees paid to the staking reward account 0.0.800."
  rewardFeeFraction: Fraction!

  "The total number to be distributed as staking rewards each period. Defaults to tinybars."
  rewardRate(unit: HbarUnit = TINYBAR): Long!

  "The minimum balance of staking reward account 0.0.800 required to active rewards. Defaults to tinybars."
  startThreshold(unit: HbarUnit = TINYBAR): Long!

  "The consensus timestamp range the staking period spans."
  timestamp: TimestampRange!

  "The total amount staked to the network as of the start of the current staking period. Defaults to tinybars."
  total(unit: HbarUnit = TINYBAR): Long!
}

"The network's released supply of hbars."
type NetworkSupply implements Node {
  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The network's released supply of hbars. Defaults to tinybars."
  releasedSupply(unit: HbarUnit = TINYBAR): Long!

  "The consensus timestamp at which the released supply was valid."
  timestamp: Timestamp!

  "The network's total supply of hbars. Defaults to tinybars."
  totalSupply(unit: HbarUnit = TINYBAR): Long!
}
```

### Schedule

Users can query for a specific Hedera Schedule.

```graphql
"A schedule entity allows a transaction to be scheduled for future execution."
type Schedule implements Entity & Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "The entity who created the schedule."
  creator: Accountable!

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  "The consensus timestamp at which this schedule was executed."
  executedTimestamp: Timestamp

  "The timestamp when the transaction should be evaluated for execution and then expire."
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The memo associated with the entity."
  memo: String!

  "The entity to be charged the service fee for the scheduled transaction execution."
  payer: Accountable!

  "The signatures that have signed the scheduled transaction."
  signatures: [TransactionSignature!]!

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!

  "The scheduled transaction body to be executed in the future. Encoded bytes of SchedulableTransactionBody protobuf."
  transactionBody(encoding: BinaryEncoding = BASE64): String!

  """
  Whether the scheduled transaction will be evaluated for execution at its expiration time instead of when all
  required signatures are received.
  """
  waitForExpiry: Boolean!
}

"The unique identifier to get a specific schedule."
input ScheduleIdInput {
  "The unique shard, realm, and number associated with a Hedera schedule."
  entityId: EntityIdInput!
}

"A signature corresponding to the unique public key used to sign a given transaction."
type TransactionSignature {
  "First few bytes of the public key."
  publicKeyPrefix(encoding: BinaryEncoding = BASE64): String!

  "The contents of the signature used to sign the transaction."
  signature(encoding: BinaryEncoding = BASE64): String!

  "The consensus timestamp at which the scheduled transaction was signed."
  timestamp: Timestamp!

  "The type of signature used to sign the scheduled transaction."
  type: TransactionSignatureType!
}

"The type of signature used to sign the transaction."
enum TransactionSignatureType {
  ECDSA_SECP256K1
  ED25519
  UNKNOWN
}
```

### Token

Users can query for a specific Hedera token and its associated info like NFTs.

```graphql
"A transfer fee to assess during a CryptoTransfer."
interface CustomFee {
  "Whether all the token's fee collection accounts are exempt from this fee."
  allCollectorsAreExempt: Boolean!

  "The number of units to assess as a fee."
  amount: Fraction!

  "The account to receive the custom fee."
  collectorAccountId: EntityId

  "The consensus timestamp at which this custom fee was created on the network."
  createdTimestamp: Timestamp!
}

"A fixed number of units to assess as a fee during any transfer of the token to which this fixed fee is attached."
type FixedFee implements CustomFee {
  "Whether all the token's fee collection accounts are exempt from this fee."
  allCollectorsAreExempt: Boolean!

  "The number of units to assess as a fee."
  amount: Fraction!

  "The account to receive the custom fee."
  collectorAccountId: EntityId

  "The consensus timestamp at which this custom fee was created on the network."
  createdTimestamp: Timestamp!

  "The denomination of the fee; taken as hbar if left unset."
  denominatingTokenId: EntityId
}

"A fraction of the transferred units of a token to assess as a fee."
type FractionalFee implements CustomFee {
  "Whether all the token's fee collection accounts are exempt from this fee."
  allCollectorsAreExempt: Boolean!

  "The number of units to assess as a fee."
  amount: Fraction!

  "The account to receive the custom fee."
  collectorAccountId: EntityId

  "The consensus timestamp at which this custom fee was created on the network."
  createdTimestamp: Timestamp!

  "The maximum amount to assess (zero implies no maximum)"
  maximumAmount: Long!

  "The minimum amount to assess"
  minimumAmount: Long!

  "If false, the receiver does not get the full amount, but only what is left over after paying the fractional fee."
  netOfTransfers: Boolean!
}

"The freeze status of the token."
enum FreezeStatus {
  FROZEN
  NOT_APPLICABLE
  UNFROZEN
}

"The KYC status of the token."
enum KycStatus {
  GRANTED
  NOT_APPLICABLE
  REVOKED
}

"A unique non-fungible token."
type Nft implements Node {
  "The current owner of the NFT"
  accountId: EntityId

  "The consensus timestamp at which the NFT was created."
  createdTimestamp: Timestamp

  "The spender who is granted approved for all allowance and granting approval on an NFT serial to another spender."
  delegatingSpenderId: EntityId

  "Whether the NFT or the token it belongs to has been deleted."
  deleted: Boolean

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "Represents the unique metadata of the NFT."
  metadata(encoding: BinaryEncoding = BASE64): String

  "The consensus timestamp at which the NFT was last modified."
  modifiedTimestamp: Timestamp!

  "The unique identifier of this instance."
  serialNumber: Long!

  "If an allowance is granted for the NFT, its corresponding spender account."
  spenderId: EntityId
}

"The connection type for Nft."
type NftConnection {
  "A list of edges."
  edges: [NftEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NftEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: Nft!
}

"The unique identifier to get a specific NFT within a token class."
input NftIdInput {
  "The NFT's unique serial number within the token class."
  serialNumber: Long!
}

"A fee to assess during a CryptoTransfer that changes ownership of an NFT."
type RoyaltyFee implements CustomFee {
  "Whether all the token's fee collection accounts are exempt from this fee."
  allCollectorsAreExempt: Boolean!

  "The number of units to assess as a fee."
  amount: Fraction!

  "The account to receive the custom fee."
  collectorAccountId: EntityId

  "The consensus timestamp at which this custom fee was created on the network."
  createdTimestamp: Timestamp!

  "If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged with the sender."
  fallbackFee: FixedFee
}

"Represents a Hedera token on the network."
type Token implements Entity & Node {
  "Lists the accounts associated to this token."
  accounts(after: String, before: String, first: Int, last: Int): TokenAssociationConnection!

  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Lists this token's custom fees to collect during transfers."
  customFees: [CustomFee!]!

  "For FUNGIBLE_COMMON, the number of decimal places a token is divisible by. For NON_FUNGIBLE_UNIQUE, will be zero."
  decimals: Long!

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "The key which can change the token's custom fee schedule."
  feeScheduleKey: Object

  "The default freeze status of Hedera accounts associated to this token."
  freezeDefault: Boolean!

  "The key which can freeze or unfreeze an account for token transactions."
  freezeKey: Object

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "Specifies the initial supply of tokens to be put in circulation and sent to the treasury account."
  initialSupply: Long!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The key which can grant or revoke KYC of an account for the token's transactions."
  kycKey: Object

  """
  For tokens of type FUNGIBLE_COMMON, the maximum number of tokens that can be in circulation. For tokens of type
  NON_FUNGIBLE_UNIQUE, the maximum number of NFTs (serial numbers) that can be minted.
  """
  maxSupply: Long!

  "The memo associated with the entity."
  memo: String!

  "The publicly visible name of the token."
  name: String!

  "Get a specific non-fungible token belonging to this token class."
  nft(id: NftIdInput!): Nft

  "The list of non-fungible tokens belonging to this token class."
  nfts(after: String, before: String, first: Int, last: Int): NftConnection!

  "The key which can pause and unpause the token."
  pauseKey: Object

  "Whether the token is paused and can have transactions change its state."
  pauseStatus: TokenPauseStatus!

  "The key which can change the supply of a token."
  supplyKey: Object

  "Whether the token has an infinite supply or not."
  supplyType: TokenSupplyType!

  "The publicly visible token symbol."
  symbol: String!

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!

  "The current supply associated with this token."
  totalSupply: Long!

  """
  The account which will act as a treasury for the token. This account will receive the specified initial supply or
  the newly minted NFTs in the case for NON_FUNGIBLE_UNIQUE Type.
  """
  treasury: Account!

  "The token class type for IWA compatibility."
  tokenType: TokenType!

  "The key which can wipe the token balance of an account."
  wipeKey: Object
}

"The unique identifier to get a specific token."
input TokenIdInput {
  "The unique shard, realm, and number associated with a Hedera token."
  entityId: EntityIdInput!
}

"Whether the token is paused and can have transactions change its state."
enum TokenPauseStatus {
  NOT_APPLICABLE
  PAUSED
  UNPAUSED
}

"Whether the token has an infinite supply or not."
enum TokenSupplyType {
  FINITE
  INFINITE
}

"The token class type."
enum TokenType {
  FUNGIBLE_COMMON
  NON_FUNGIBLE_UNIQUE
}
```

### Topic

Users can query for a specific Hedera topic and its associated messages.

```graphql
"A Hedera topic provides aBFT consensus as to the order and validity of messages submitted to it."
type Topic implements Entity & Node {
  "The account charged the auto-renewal fee."
  autoRenewEntity: Accountable

  "The amount of time to elapse before auto-renew occurs."
  autoRenewPeriod: Duration

  "The consensus timestamp at which the entity was created."
  createdTimestamp: Timestamp

  "Whether the entity still exists in consensus node state."
  deleted: Boolean

  "The unique identifier associated with the entity."
  entityId: EntityId!

  """
  The time at which this entity will expire and be auto-renewed, if possible. If this was not explicitly set by the
  user it will be calculated as the createdTimestamp plus the autoRenewPeriod.
  """
  expirationTimestamp: Timestamp

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  """
  The admin key associated with this entity whose signing requirements must be met in order to modify the entity on
  the network. This returns a dynamic map that varies per entity and may be arbitrarily complex depending upon this
  key's signing requirements.
  """
  key: Object

  "The memo associated with the entity in UTF-8."
  memo: String!

  "Lookup a specific topic message by its sequence number."
  message(id: TopicMessageIdInput!): TopicMessage

  "The list of messages associated with this topic."
  messages(after: String, before: String, first: Int, last: Int): TopicMessageConnection!

  "The key that provides access control for topic message submission."
  submitKey: Object

  "A consensus timestamp range with an inclusive from timestamp and an exclusive to timestamp."
  timestamp: TimestampRange!
}

"The unique identifier to get a specific topic."
input TopicIdInput {
  "The unique shard, realm, and number associated with a Hedera topic."
  entityId: EntityIdInput!
}

"The message submitted to the topic."
type TopicMessage implements Node {
  "The sequence number (from 1 to total) of the current chunk in the message."
  chunkNum: Int

  "The total number of chunks in the message."
  chunkTotal: Int

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The contents of the topic message."
  message(encoding: BinaryEncoding = BASE64): String!

  "A SHA-384 digest constructed from the current message and the previous running hash."
  runningHash(encoding: BinaryEncoding = BASE64): String!

  "The version of the SHA-384 digest used to update the running hash."
  runningHashVersion: Int!

  "A unique sequence number for each message on the topic."
  sequenceNumber: Long!

  "The timestamp at which this message reached consensus on the network."
  timestamp: Timestamp!

  "The generic transaction information associated with this topic message."
  transaction: Transaction!
}

"The connection type for TopicMessage."
type TopicMessageConnection {
  "A list of edges."
  edges: [TopicMessageEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TopicMessageEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: TopicMessage!
}

"""
The unique identifier to get a specific topic message. Only one of the given fields can be present at a time otherwise
an error will occur.
"""
input TopicMessageIdInput {
  "The sequence number of the topic message."
  sequenceNumber: Long

  "The topic message's consensus timestamp."
  timestamp: Timestamp
}
```

### Transaction

Users can query for a specific transaction executed on the Hedera network.

```graphql
"A custom fee that was assessed during a transfer."
type AssessedCustomFee {
  "The number of units assessed for the fee."
  amount: Long!

  "The entity to receive the assessed fee."
  collectorId: EntityId!

  "The entities whose final balances would have been higher in the absence of this assessed fee."
  effectivePayerIds: [EntityId!]!

  "The denomination of the fee; taken as hbar if left unset."
  tokenId: EntityId
}

"A transfer of hbars to or from an entity."
type CryptoTransfer {
  "The amount transferred. Negative to indicate a debit from the sender and positive for a credit from the receiver."
  amount(unit: HbarUnit = TINYBAR): Long!

  "The account or contract that sent or received the transferred amount."
  entityId: EntityId!

  "If this transfer was an approved allowance."
  isApproval: Boolean
}

"A non-fungible token transferred as a result of a transaction."
type NftTransfer {
  "If this transfer was an approved allowance."
  isApproval: Boolean

  "The account who received the NFT."
  receiverId: EntityId

  "The account who sent the NFT."
  senderId: EntityId

  "The serial number of the NFT."
  serialNumber: Long!

  "The token that was transferred."
  tokenId: EntityId!
}

"The accounts who had staking rewards paid as a result of this transaction."
type StakingRewardTransfer {
  "The number of hbars awarded."
  amount(unit: HbarUnit = TINYBAR): Long!

  "The account or contract that received the staking reward amount."
  entityId: EntityId!
}

"A token transfer that occurred as part of this transaction."
type TokenTransfer {
  "The amount of tokens transferred."
  amount: Long!

  "The account that sent or received the transferred amount, depending whether the amount is negative or positive."
  entityId: EntityId!

  "If this transfer was an approved allowance."
  isApproval: Boolean

  "The token that was transferred."
  tokenId: EntityId!
}

"Transaction contains the results of HAPI transactions on the network."
type Transaction implements Node {
  "All custom fees that were assessed during a transfer and must be paid if the transaction was successful."
  assessedCustomFees: [AssessedCustomFee!]!

  "The actual transaction fee charged to execute this transaction. Defaults to tinybars."
  chargedFee(unit: HbarUnit = TINYBAR): Long

  "The main Hedera entity associated with this transaction. For create transactions, the newly created entity's ID."
  entityId: EntityId

  "The hash of the transaction that was executed."
  hash: String

  "An opaque, globally unique identifier specific to GraphQL."
  id: ID!

  "The position of the transaction within the block."
  index: Int

  "The initial amount of hbars to put into the created account or contract, if a create transaction."
  initialBalance(unit: HbarUnit = TINYBAR): Long

  "The maximum transaction fee the client is willing to pay. Defaults to tinybars."
  maxFee(unit: HbarUnit = TINYBAR): Long

  "Any note or description that accompanied the transaction."
  memo: String

  "The account of the node that submits the client's transaction to the network."
  nodeAccountId: EntityId

  "In the record of an internal child transaction, the consensus timestamp of the user transaction that spawned it."
  parent: Transaction

  """
  The consensus status of the transaction. Considered unsuccessful if the value is anything other than
  FEE_SCHEDULE_FILE_PART_UPLOADED, SUCCESS, or SUCCESS_BUT_MISSING_EXPECTED_OPERATION. See the HAPI protobuf
  ResponseCodeEnum for a full list of values.
  """
  result: String!

  "The timestamp at which this transaction reached consensus."
  timestamp: Timestamp!

  "The ID of the transaction."
  transactionId: TransactionId!

  "The different type of transfers that resulted from this transaction."
  transfers: Transfers!

  "The type of HAPI transaction."
  type: TransactionType!

  "The period of time after the valid start for which this transaction must reach consensus."
  validDuration: Duration
}

"The connection type for Transaction."
type TransactionConnection {
  "A list of edges."
  edges: [TransactionEdge!]!

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TransactionEdge {
  "The cursor associated with this edge."
  cursor: String!

  "The item associated with the edge."
  node: Transaction!
}

"The unique client-generated ID for the transaction."
type TransactionId {
  "The incrementing identifier for an internal transaction that was spawned as part of handling a user transaction."
  nonce: Int!

  "The account that paid for this transaction."
  payerAccountId: EntityId!

  "Whether the transaction is scheduled transaction."
  scheduled: Boolean!

  "The transaction is considered valid if it reaches consensus on or before this time."
  validStart: Timestamp!
}

"The transaction ID to be used as input to search for a transaction."
input TransactionIdInput {
  "The incrementing identifier for an internal transaction that was spawned as part of handling a user transaction."
  nonce: Int! = 0 @Min(value: 0)

  "The account that paid for this transaction."
  payerAccountId: EntityIdInput!

  "Whether the transaction is a scheduled transaction."
  scheduled: Boolean! = false

  "The transaction is considered valid if it reaches consensus on or before this time."
  validStart: Timestamp!
}

"""
The unique identifier to find a specific transaction. Only one of the given fields can be present at a time otherwise an
error will occur.
"""
input TransactionInput {
  "The transaction's consensus timestamp."
  timestamp: Timestamp

  "The unique client-generated ID for the transaction."
  transactionId: TransactionIdInput
}

"The different type of transfers that resulted from this transaction."
type Transfers {
  "The crypto transfers that resulted from this transaction, including any transaction fees."
  crypto: [CryptoTransfer!]!

  "The non-fungible tokens transferred as a result of this transaction."
  nft: [NftTransfer!]!

  "List of accounts who had staking rewards paid as a result of this transaction."
  stakingReward: [StakingRewardTransfer!]!

  "List of token transfers that occurred as part of this transaction."
  token: [TokenTransfer!]!
}
```

## Backwards Compatibility

This HIP introduces a new mirror node API and as such introduces no backwards compatibility concerns. The existing
mirror node REST API will continue to be maintained and new features will be added to both APIs going forward.

## Security Implications

A new API can increase the load on the database and will have to be architected in such a way as to be scalable via the
normal techniques like caching, data replication, horizontal auto-scaling, etc. In contrast to REST APIs, users can
request significantly more data in a single request since they control the response format. As a result, the mirror node
GraphQL implementation will enforce limits in a number of areas to ensure any single query doesn't negatively impact
other users. Different mirror node operators may choose to decrease or increase these limits to suit their needs.

### Query Timeout

A maximum time to process a GraphQL query will be enforced via a query timeout. The exact query timeout will be
determined based upon performance testing.

### Query Depth Limit

Query depth will be limited to at most 4 levels so that calls cannot recurse infinitely and overwhelm the server. The
exact query depth will be determined based upon performance testing.

### List Size Limit

Limiting each list is necessary to reduce the multiplier of having nested queries. Any list will be limited to at
most 100 items. Each of those list could potentially contain other lists who are each similarly constrained to 100 items
and so on. The exact number may change in the future depending upon performance testing.

### Query Complexity Limit

A query complexity score will be calculated from the query and any request that exceeds the maximum complexity score
will be rejected. The complexity of a query is calculated by summing up the number of requested fields multiplied by the
number of items requested in the list. The exact complexity limit will be determined based upon performance testing.

### IP Rate Limit

An IP-based rate limit will be enforced at the load balancer level to ensure any one client does not overwhelm the
API endpoint. Since a single GraphQL call might be the equivalent of many REST API calls, this limit might be lower
than the REST API limit. The exact rate limit will be determined based upon performance testing.

### Complexity Rate Limit

The complexity score used to calculate the per query limit could also be used to keep a running total of a client's
API use during a period of time. Mirror node operators may choose to monitor and use these points to limit the maximum
number of points a client can use per hour.

### HTTP Caching

Most HTTP caching technologies like CDNs are unable to cache HTTP POST requests that GraphQL uses by default. However,
GraphQL can also be sent as an HTTP GET request where the query, operationName, and its variables are encoded as HTTP
query parameters. This approach allows the server to provide a `Cache-Control` header so that CDNs can cache it
appropriately. This HIP recommends implementations explore this approach but does not require it.

## How to Teach This

The new GraphQL API will be developed in a contract-first manner using standard GraphQL schema files. These schema files
will contain extensive comments for every operation, type, and field present to document their intended purpose. A local
or hosted [GraphiQL](https://github.com/graphql/graphiql) explorer can be used for easy exploration of the
available queries. Additional documentation will be provided by Hedera to instruct users how to use the new API.

## Reference Implementation

A reference implementation is underway on the Mirror Node GitHub repository. The results of this effort will manifest
themselves as a new `hedera-mirror-graphql` module and associated microservice. GitHub issues labeled
with [graphql](https://github.com/hashgraph/hedera-mirror-node/issues?q=is%3Aissue+is%3Aopen+graphql+label%3Agraphql)
or the GraphQL API [epic](https://github.com/hashgraph/hedera-mirror-node/issues/5304) can be used by interested
parties to track the progress of this work.

## Rejected Ideas

### REST API Projections

The current REST API could be enhanced to provide some benefits of GraphQL like field selection (projection) or
nested pagination. Field selection would take a some amount of effort to rewrite queries to have dynamic select
statements. Problems arise when attempting to design a manner to specify via query parameters what fields to return when
those fields are on nested objects. There is no standard syntax in REST API for projection. Likewise, nested pagination
is tricky to support since there is no concept of parameters on nested lists to support limit, order and cursor.

### GraphQL Mutations

Mirror nodes are read only and as a result users can't modify their state via a GraphQL mutation.

### GraphQL Subscriptions

Mirror nodes do eventually want to support subscriptions to deliver real-time updates, but to reduce the scope of this
HIP we have intentionally excluded it at this time. We will revisit support for subscriptions at a later point in time
once the mirror node team finalizes the scalability of its data architecture.

## Open Issues

## References

* [Mirror Node GitHub](https://github.com/hashgraph/hedera-mirror-node)
* [REST OpenAPI Documentation](https://mainnet-public.mirrornode.hedera.com/api/v1/docs)
* [GraphQL Specification](https://spec.graphql.org/)
* [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
* [GraphQL Relay Specification](https://relay.dev/docs/guides/graphql-server-specification/)
* [GraphiQL](https://github.com/graphql/graphiql)
* [Hgraph.io](https://www.hgraph.io/)

## Copyright/license

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](../LICENSE)
or (https://www.apache.org/licenses/LICENSE-2.0)

